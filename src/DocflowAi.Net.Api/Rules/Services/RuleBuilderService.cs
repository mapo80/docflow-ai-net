using System.Text;
using System.Text.Json.Nodes;
using System.Text.RegularExpressions;

namespace DocflowAi.Net.Api.Rules.Services;

/// <summary>
/// Provides validation and compilation for block-based rule definitions.
/// </summary>
public class RuleBuilderService
{
    public record CompileReq(JsonArray Blocks);
    public record ValidateResp(string Path, string Message);

    public (bool Ok, IReadOnlyList<ValidateResp> Errors) Validate(CompileReq req)
    {
        var errors = new List<ValidateResp>();
        int i = 0;
        foreach (var b in req.Blocks)
        {
            var o = b!.AsObject();
            var type = o["type"]?.ToString();
            var field = o["field"]?.ToString();
            string path = $"blocks[{i}]";
            if (string.IsNullOrWhiteSpace(type))
                errors.Add(new(path, "type is required"));
            if (string.IsNullOrWhiteSpace(field) && type != "set")
                errors.Add(new(path + ".field", "field is required"));

            switch (type)
            {
                case "compare":
                    var op = o["op"]?.ToString();
                    var val = o["value"]?.ToString();
                    if (string.IsNullOrWhiteSpace(op) || !"== != > >= < <=".Split(' ').Contains(op))
                        errors.Add(new(path + ".op", "invalid compare op"));
                    if (string.IsNullOrWhiteSpace(val))
                        errors.Add(new(path + ".value", "value required"));
                    break;
                case "regex":
                    var pat = o["pattern"]?.ToString() ?? string.Empty;
                    try { _ = new Regex(pat); }
                    catch { errors.Add(new(path + ".pattern", "invalid regex")); }
                    break;
                case "set":
                    var tgt = o["target"]?.ToString();
                    if (string.IsNullOrWhiteSpace(tgt))
                        errors.Add(new(path + ".target", "target is required"));
                    break;
                case "normalize":
                    var kind = o["kind"]?.ToString();
                    if (kind is null || (kind != "number" && kind != "date"))
                        errors.Add(new(path + ".kind", "kind must be 'number' or 'date'"));
                    break;
                case "map":
                    var fn = o["fn"]?.ToString();
                    if (string.IsNullOrWhiteSpace(fn))
                        errors.Add(new(path + ".fn", "fn is required (C# expression using 'x')"));
                    break;
                case "deduce":
                    var from = o["from"]?.AsArray()?.Select(x => x!.ToString()).ToArray() ?? Array.Empty<string>();
                    var outField = o["target"]?.ToString();
                    if (from.Length == 0)
                        errors.Add(new(path + ".from", "at least one source field required"));
                    if (string.IsNullOrWhiteSpace(outField))
                        errors.Add(new(path + ".target", "target required"));
                    break;
                case "when":
                    var cond = o["cond"]?.ToString();
                    if (string.IsNullOrWhiteSpace(cond))
                        errors.Add(new(path + ".cond", "condition is required (C# expression)"));
                    break;
                case "calc":
                    var target = o["target"]?.ToString();
                    var expr = o["expr"]?.ToString();
                    if (string.IsNullOrWhiteSpace(target))
                        errors.Add(new(path + ".target", "target required"));
                    if (string.IsNullOrWhiteSpace(expr))
                        errors.Add(new(path + ".expr", "expr required (C# expression, use g.Get<T>(\"field\"))"));
                    break;
            }
            i++;
        }
        return (errors.Count == 0, errors);
    }

    public (bool Ok, string? Code, IReadOnlyList<ValidateResp> Errors) Compile(CompileReq req)
    {
        var validation = Validate(req);
        if (!validation.Ok)
            return (false, null, validation.Errors);

        var sb = new StringBuilder();
        sb.AppendLine("// generated by builder");

        foreach (var b in req.Blocks)
        {
            var o = b!.AsObject();
            var type = o["type"]!.ToString();
            var field = o["field"]?.ToString();

            if (type == "exists")
            {
                sb.AppendLine($"  // exists {field}");
                sb.AppendLine($"  _ = g.Has(\"{field}\");");
            }
            else if (type == "compare")
            {
                var op = o["op"]!.ToString();
                var val = o["value"]!.ToString();
                var isNum = double.TryParse(val, out _);
                var getter = isNum ? $"g.Get<double>(\"{field}\")" : $"g.Get<string>(\"{field}\")";
                sb.AppendLine($"  if ({getter} {op} {(isNum ? val : $"\"{val}\"")}) {{ /* TODO: action */ }}");
            }
            else if (type == "regex")
            {
                var pat = o["pattern"]!.ToString().Replace("\\", "\\\\").Replace("\"", "\\\"");
                sb.AppendLine($"  // regex {field} =~ /{pat}/");
                sb.AppendLine($"  if (System.Text.RegularExpressions.Regex.IsMatch(g.Get<string>(\"{field}\"), \"{pat}\")) {{ /* TODO */ }}");
            }
            else if (type == "set")
            {
                var tgt = o["target"]!.ToString();
                sb.AppendLine($"  g.Set(\"{tgt}\", g.Get<object>(\"{field}\"));");
            }
            else if (type == "normalize")
            {
                var kind = o["kind"]!.ToString();
                if (kind == "number")
                {
                    sb.AppendLine($"  if (double.TryParse(g.Get<string>(\"{field}\"), out var n_{field})) g.Set(\"{field}\", n_{field});");
                }
                else if (kind == "date")
                {
                    sb.AppendLine($"  if (DateTimeOffset.TryParse(g.Get<string>(\"{field}\"), out var d_{field})) g.Set(\"{field}\", d_{field}.UtcDateTime.ToString(\"O\"));");
                }
            }
            else if (type == "map")
            {
                var fn = o["fn"]!.ToString();
                sb.AppendLine($"  var __x_{field} = g.Get<object>(\"{field}\");");
                sb.AppendLine($"  var __y_{field} = ({fn}); // x is __x_{field}");
                sb.AppendLine($"  g.Set(\"{field}\", __y_{field});");
            }
            else if (type == "deduce")
            {
                var tgt = o["target"]!.ToString();
                var from = o["from"]!.AsArray()!.Select(x => x!.ToString()).ToArray();
                var list = string.Join(", ", from.Select(f => $"g.Get<object>(\"{f}\")"));
                sb.AppendLine($"  // deduce {tgt} from {string.Join(",", from)}");
                sb.AppendLine("  // TODO: plug custom logic or LLM hint");
                sb.AppendLine($"  if ({string.Join(" && ", from.Select(f => $"g.Has(\"{f}\")"))}) g.Set(\"{tgt}\", new object[] {{ {list} }});");
            }
            else if (type == "when")
            {
                var cond = o["cond"]!.ToString().Replace("\\", "\\\\").Replace("\"", "\\\"");
                sb.AppendLine($"  if ({cond}) {{ /* TODO */ }}");
            }
            else if (type == "calc")
            {
                var tgt = o["target"]!.ToString();
                var expr = o["expr"]!.ToString();
                sb.AppendLine($"  g.Set(\"{tgt}\", {expr});");
            }
        }

        return (true, sb.ToString(), Array.Empty<ValidateResp>());
    }
}

